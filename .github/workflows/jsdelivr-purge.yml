name: Purge jsDelivr Cache

on:
  push:
    branches:
      - main
    paths:
      - '*.js'
      - '*.css'
    tags:
      - '*'
  release:
    types: [published]

jobs:
  purge-cache:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags
          ref: ${{ github.ref }}

      - name: Get changed files
        id: changed_files
        run: |
          CURRENT_TAG=""
          
          if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && ! echo "${{ github.ref }}" | grep -q "^refs/tags/"; then
            # For branch pushes, get files changed in this commit
            CHANGED_FILES=$(git diff --name-only --diff-filter=ACMR "${{ github.event.before }}" HEAD | grep -E '\.(js|css)$' || true)
            echo "Event: Branch push to main"
          elif [ "${{ github.event_name }}" = "release" ]; then
            # For GitHub release events
            CURRENT_TAG="${{ github.event.release.tag_name }}"
          elif echo "${{ github.ref }}" | grep -q "^refs/tags/"; then
            # For tag push events
            CURRENT_TAG=$(echo "${{ github.ref }}" | sed 's/refs\/tags\///')
          fi
          
          if [ -n "$CURRENT_TAG" ]; then
            # For releases/tag pushes, compare with previous tag
            echo "Current tag: $CURRENT_TAG"
            
            # Get previous tag (excluding current tag)
            PREVIOUS_TAG=$(git tag --sort=-creatordate | grep -v "^$CURRENT_TAG$" | head -1 || echo "")
            
            if [ -z "$PREVIOUS_TAG" ]; then
              echo "No previous tag found, purging all JS/CSS files"
              CHANGED_FILES=$(git ls-files | grep -E '\.(js|css)$' || true)
            else
              echo "Previous tag: $PREVIOUS_TAG"
              # Get files changed between previous tag and current tag
              CHANGED_FILES=$(git diff --name-only --diff-filter=ACMR "$PREVIOUS_TAG" "$CURRENT_TAG" | grep -E '\.(js|css)$' || true)
            fi
            echo "Event: Release/Tag push"
          else
            # Fallback: get all JS/CSS files
            CHANGED_FILES=$(git ls-files | grep -E '\.(js|css)$' || true)
            echo "Event: Fallback (unknown event type)"
          fi
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No JS or CSS files changed"
            echo "files=" >> $GITHUB_OUTPUT
          else
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # Convert newlines to space-separated list
            FILES_LIST=$(echo "$CHANGED_FILES" | tr '\n' ' ')
            echo "files=$FILES_LIST" >> $GITHUB_OUTPUT
          fi

      - name: Purge jsDelivr cache for changed files
        if: steps.changed_files.outputs.files != ''
        run: |
          # Function to purge with retry logic
          purge_with_retry() {
            local url=$1
            local file=$2
            local max_retries=5
            local retry_delay=30  # Start with 30s for rate limits
            local attempt=1
            
            while [ $attempt -le $max_retries ]; do
              echo "Attempt $attempt/$max_retries: Purging $file"
              
              # Make the purge request
              response=$(curl -s -w "\n%{http_code}" -X POST "$url" -H "Accept: application/json" --max-time 30 2>&1)
              http_code=$(echo "$response" | tail -n1)
              body=$(echo "$response" | sed '$d')
              
              # Check if successful (200 or 201)
              if [ "$http_code" = "200" ] || [ "$http_code" = "201" ]; then
                echo "✅ Successfully purged $file (HTTP $http_code)"
                echo "$body" | head -c 300
                echo ""
                return 0
              elif [ "$http_code" = "429" ]; then
                # Rate limited - wait longer (jsDelivr throttles for ~60 seconds)
                if [ $attempt -eq 1 ]; then
                  retry_delay=30  # First retry: wait 30s
                elif [ $attempt -eq 2 ]; then
                  retry_delay=60  # Second retry: wait 60s
                elif [ $attempt -eq 3 ]; then
                  retry_delay=90  # Third retry: wait 90s
                else
                  retry_delay=120  # Fourth+ retry: wait 120s
                fi
                echo "⚠️  Rate limited (HTTP 429), waiting ${retry_delay}s before retry..."
                echo "   (jsDelivr typically throttles for ~60 seconds)"
                sleep $retry_delay
                attempt=$((attempt + 1))
              elif [ "$http_code" = "503" ] || [ "$http_code" = "502" ]; then
                # Service unavailable - retry with shorter delay
                echo "⚠️  Service unavailable (HTTP $http_code), waiting 10s before retry..."
                sleep 10
                attempt=$((attempt + 1))
              else
                echo "❌ Failed to purge $file (HTTP $http_code)"
                echo "$body" | head -c 300
                echo ""
                # For non-retryable errors, don't retry
                return 1
              fi
            done
            
            echo "❌ Failed to purge $file after $max_retries attempts"
            return 1
          }
          
          FILES="${{ steps.changed_files.outputs.files }}"
          PURGE_COUNT=0
          FAILED_FILES=""
          
          for file in $FILES; do
            if [ -f "$file" ]; then
              echo ""
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo "Processing: $file"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              
              # Purge @main
              if purge_with_retry "https://purge.jsdelivr.net/gh/pontuslagerberg/whiteswan@main/$file" "$file (@main)"; then
                PURGE_COUNT=$((PURGE_COUNT + 1))
              else
                FAILED_FILES="$FAILED_FILES $file(@main)"
              fi
              
              # Add delay between requests to avoid throttling (longer delay)
              sleep 3
              
              # Purge @latest
              if purge_with_retry "https://purge.jsdelivr.net/gh/pontuslagerberg/whiteswan@latest/$file" "$file (@latest)"; then
                PURGE_COUNT=$((PURGE_COUNT + 1))
              else
                FAILED_FILES="$FAILED_FILES $file(@latest)"
              fi
              
              # Add delay between files to avoid throttling (longer delay)
              sleep 3
            fi
          done
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Purge Summary: $PURGE_COUNT successful"
          if [ -n "$FAILED_FILES" ]; then
            echo "⚠️  Warning: Some files failed to purge:$FAILED_FILES"
            echo "   These files may need manual cache purging or will update on next release."
            echo "   The workflow will continue (non-blocking)."
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            # Don't exit with error - allow workflow to complete
            # Cache will eventually update, or can be manually purged
          else
            echo "✅ All purges completed successfully!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          fi

      - name: Summary
        run: |
          if [ "${{ steps.changed_files.outputs.files }}" != "" ]; then
            echo "✅ jsDelivr cache purge completed for changed files"
            echo "Files purged:"
            echo "${{ steps.changed_files.outputs.files }}" | tr ' ' '\n'
            echo ""
            echo "Files are now available at:"
            echo "  - https://cdn.jsdelivr.net/gh/pontuslagerberg/whiteswan@main/"
            echo "  - https://cdn.jsdelivr.net/gh/pontuslagerberg/whiteswan@latest/"
          else
            echo "ℹ️  No JS or CSS files were changed in this commit"
          fi

