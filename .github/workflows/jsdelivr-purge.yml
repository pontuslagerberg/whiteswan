name: Purge jsDelivr Cache

on:
  push:
    branches:
      - main
    paths:
      - '*.js'
      - '*.css'
    tags:
      - '*'
  release:
    types: [published]

jobs:
  purge-cache:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history for tags
          ref: ${{ github.ref }}

      - name: Get changed files
        id: changed_files
        run: |
          CURRENT_TAG=""
          
          if [ "${{ github.event_name }}" = "push" ] && [ -n "${{ github.event.before }}" ] && ! echo "${{ github.ref }}" | grep -q "^refs/tags/"; then
            # For branch pushes, get files changed in this commit
            CHANGED_FILES=$(git diff --name-only --diff-filter=ACMR "${{ github.event.before }}" HEAD | grep -E '\.(js|css)$' || true)
            echo "Event: Branch push to main"
          elif [ "${{ github.event_name }}" = "release" ]; then
            # For GitHub release events
            CURRENT_TAG="${{ github.event.release.tag_name }}"
          elif echo "${{ github.ref }}" | grep -q "^refs/tags/"; then
            # For tag push events
            CURRENT_TAG=$(echo "${{ github.ref }}" | sed 's/refs\/tags\///')
          fi
          
          if [ -n "$CURRENT_TAG" ]; then
            # For releases/tag pushes, compare with previous tag
            echo "Current tag: $CURRENT_TAG"
            
            # Get previous tag (excluding current tag)
            PREVIOUS_TAG=$(git tag --sort=-creatordate | grep -v "^$CURRENT_TAG$" | head -1 || echo "")
            
            if [ -z "$PREVIOUS_TAG" ]; then
              echo "No previous tag found, purging all JS/CSS files"
              CHANGED_FILES=$(git ls-files | grep -E '\.(js|css)$' || true)
            else
              echo "Previous tag: $PREVIOUS_TAG"
              # Get files changed between previous tag and current tag
              CHANGED_FILES=$(git diff --name-only --diff-filter=ACMR "$PREVIOUS_TAG" "$CURRENT_TAG" | grep -E '\.(js|css)$' || true)
            fi
            echo "Event: Release/Tag push"
          else
            # Fallback: get all JS/CSS files
            CHANGED_FILES=$(git ls-files | grep -E '\.(js|css)$' || true)
            echo "Event: Fallback (unknown event type)"
          fi
          
          if [ -z "$CHANGED_FILES" ]; then
            echo "No JS or CSS files changed"
            echo "files=" >> $GITHUB_OUTPUT
          else
            echo "Changed files:"
            echo "$CHANGED_FILES"
            # Convert newlines to space-separated list
            FILES_LIST=$(echo "$CHANGED_FILES" | tr '\n' ' ')
            echo "files=$FILES_LIST" >> $GITHUB_OUTPUT
          fi

      - name: Purge jsDelivr cache for changed files
        if: steps.changed_files.outputs.files != ''
        run: |
          # Function to purge with retry logic using the correct jsDelivr API
          purge_with_retry() {
            local path=$1
            local file=$2
            local max_retries=5
            local retry_delay=30
            local attempt=1
            
            while [ $attempt -le $max_retries ]; do
              echo "Attempt $attempt/$max_retries: Purging $file"
              
              # Step 1: POST to purge.jsdelivr.net with JSON body
              purge_response=$(curl -s -w "\n%{http_code}" -X POST "https://purge.jsdelivr.net" \
                -H "Content-Type: application/json" \
                -H "Accept: application/json" \
                -d "{\"path\": [\"$path\"]}" \
                --max-time 30 2>&1)
              
              http_code=$(echo "$purge_response" | tail -n1)
              purge_body=$(echo "$purge_response" | sed '$d')
              
              # Check if purge request was accepted (200, 201, or 202 are all success)
              if [ "$http_code" = "200" ] || [ "$http_code" = "201" ] || [ "$http_code" = "202" ]; then
                # Extract job ID from response
                job_id=$(echo "$purge_body" | grep -o '"id"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 || echo "")
                
                if [ -z "$job_id" ]; then
                  echo "⚠️  Could not extract job ID from response"
                  echo "$purge_body" | head -c 300
                  echo ""
                  # Retry
                  sleep $retry_delay
                  retry_delay=$((retry_delay * 2))
                  attempt=$((attempt + 1))
                  continue
                fi
                
                echo "  Job ID: $job_id"
                
                # Step 2: Poll status endpoint until finished
                local max_polls=30
                local poll_count=0
                local poll_delay=2
                
                while [ $poll_count -lt $max_polls ]; do
                  sleep $poll_delay
                  poll_count=$((poll_count + 1))
                  
                  status_response=$(curl -s -X GET "https://purge.jsdelivr.net/status/$job_id" \
                    -H "Accept: application/json" \
                    --max-time 10 2>&1)
                  
                  status=$(echo "$status_response" | grep -o '"status"[[:space:]]*:[[:space:]]*"[^"]*"' | cut -d'"' -f4 || echo "")
                  
                  if [ "$status" = "finished" ]; then
                    # Check if any paths were throttled
                    throttled=$(echo "$status_response" | grep -o '"throttled"[[:space:]]*:[[:space:]]*true' || echo "")
                    
                    if [ -n "$throttled" ]; then
                      echo "⚠️  Purge completed but path was throttled"
                      echo "$status_response" | head -c 500
                      echo ""
                      # Retry after longer delay
                      if [ $attempt -lt $max_retries ]; then
                        echo "  Waiting ${retry_delay}s before retry..."
                        sleep $retry_delay
                        retry_delay=$((retry_delay * 2))
                        attempt=$((attempt + 1))
                        break
                      else
                        echo "❌ Path throttled after $max_retries attempts"
                        return 1
                      fi
                    else
                      echo "✅ Successfully purged $file"
                      echo "$status_response" | head -c 500
                      echo ""
                      return 0
                    fi
                  elif [ "$status" = "failed" ]; then
                    echo "❌ Purge job failed"
                    echo "$status_response" | head -c 500
                    echo ""
                    return 1
                  elif [ "$status" = "pending" ]; then
                    echo "  Status: pending (poll $poll_count/$max_polls)..."
                  else
                    echo "  Status: $status (poll $poll_count/$max_polls)..."
                  fi
                done
                
                if [ $poll_count -ge $max_polls ]; then
                  echo "⚠️  Timeout waiting for purge to complete, retrying..."
                  sleep $retry_delay
                  retry_delay=$((retry_delay * 2))
                  attempt=$((attempt + 1))
                fi
                
              elif [ "$http_code" = "429" ]; then
                # Rate limited - wait longer
                if [ $attempt -eq 1 ]; then
                  retry_delay=30
                elif [ $attempt -eq 2 ]; then
                  retry_delay=60
                elif [ $attempt -eq 3 ]; then
                  retry_delay=90
                else
                  retry_delay=120
                fi
                echo "⚠️  Rate limited (HTTP 429), waiting ${retry_delay}s before retry..."
                sleep $retry_delay
                attempt=$((attempt + 1))
              elif [ "$http_code" = "503" ] || [ "$http_code" = "502" ]; then
                echo "⚠️  Service unavailable (HTTP $http_code), waiting 10s before retry..."
                sleep 10
                attempt=$((attempt + 1))
              else
                echo "❌ Failed to initiate purge (HTTP $http_code)"
                echo "$purge_body" | head -c 300
                echo ""
                return 1
              fi
            done
            
            echo "❌ Failed to purge $file after $max_retries attempts"
            return 1
          }
          
          FILES="${{ steps.changed_files.outputs.files }}"
          PURGE_COUNT=0
          FAILED_FILES=""
          
          for file in $FILES; do
            if [ -f "$file" ]; then
              echo ""
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              echo "Processing: $file"
              echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
              
              # Purge @main
              if purge_with_retry "/gh/pontuslagerberg/whiteswan@main/$file" "$file (@main)"; then
                PURGE_COUNT=$((PURGE_COUNT + 1))
              else
                FAILED_FILES="$FAILED_FILES $file(@main)"
              fi
              
              # Add delay between requests to avoid throttling
              sleep 3
              
              # Purge @latest
              if purge_with_retry "/gh/pontuslagerberg/whiteswan@latest/$file" "$file (@latest)"; then
                PURGE_COUNT=$((PURGE_COUNT + 1))
              else
                FAILED_FILES="$FAILED_FILES $file(@latest)"
              fi
              
              # Add delay between files to avoid throttling (longer delay)
              sleep 3
            fi
          done
          
          echo ""
          echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          echo "Purge Summary: $PURGE_COUNT successful"
          if [ -n "$FAILED_FILES" ]; then
            echo "⚠️  Warning: Some files failed to purge:$FAILED_FILES"
            echo "   These files may need manual cache purging or will update on next release."
            echo "   The workflow will continue (non-blocking)."
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
            # Don't exit with error - allow workflow to complete
            # Cache will eventually update, or can be manually purged
          else
            echo "✅ All purges completed successfully!"
            echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
          fi

      - name: Summary
        run: |
          if [ "${{ steps.changed_files.outputs.files }}" != "" ]; then
            echo "✅ jsDelivr cache purge completed for changed files"
            echo "Files purged:"
            echo "${{ steps.changed_files.outputs.files }}" | tr ' ' '\n'
            echo ""
            echo "Files are now available at:"
            echo "  - https://cdn.jsdelivr.net/gh/pontuslagerberg/whiteswan@main/"
            echo "  - https://cdn.jsdelivr.net/gh/pontuslagerberg/whiteswan@latest/"
          else
            echo "ℹ️  No JS or CSS files were changed in this commit"
          fi

